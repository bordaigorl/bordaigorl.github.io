<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Emanuele D'Osualdo</title>
    <description>My research, projects and blog</description>
    <link>http://emanueledosualdo.com/</link>
    <atom:link href="http://emanueledosualdo.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 09 Nov 2022 23:39:37 +0000</pubDate>
    <lastBuildDate>Wed, 09 Nov 2022 23:39:37 +0000</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Announcement: Marie-Curie Fellowship</title>
        <description>&lt;p&gt;I am very happy to announce that from September 2018 I will be a &lt;strong&gt;Marie-Curie Fellow&lt;/strong&gt; at Imperial College.
My project “&lt;strong&gt;Ve&lt;/strong&gt;rification through &lt;strong&gt;S&lt;/strong&gt;ecurity and &lt;strong&gt;P&lt;/strong&gt;rogress &lt;strong&gt;A&lt;/strong&gt;bstractions” (VeSPA) was awarded a &lt;a href=&quot;https://ec.europa.eu/research/mariecurieactions/actions/individual-fellowships_en&quot;&gt;Marie-Curie Individual Fellowship&lt;/a&gt; for 2 years.
I will be working with Philippa Gardner to explore new ways to effectively prove &lt;strong&gt;Progress&lt;/strong&gt; (aka liveness) and &lt;strong&gt;Security&lt;/strong&gt; (eg. secrecy) of concurrent programs.&lt;/p&gt;

&lt;h2 id=&quot;project-background&quot;&gt;Project background&lt;/h2&gt;

&lt;p&gt;With the growing number of sensitive tasks that we delegate to algorithms, the development of methods to certify their trustworthiness is of paramount importance. The VeSPA project is grounded in formal methods: the challenge is to certify correctness criteria with a mathematically rigorous—and, ideally, automatically produced—proof. Modern technology is characterised by a shift of paradigm: the view of computation as carried out by a single agent as a sequence of steps transforming some input into some output—aka sequential computation—is not a satisfactory model of real-world systems anymore. Instead, we are increasingly relying on software that is organised as a decentralised collection of interacting components: our mobile phones, web servers, even our watches. Computation/services carried out by a dynamic network of interacting components is what we call &lt;em&gt;concurrent&lt;/em&gt; computation. Our trust in these systems relies on a range of interdependent properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Safety:&lt;/strong&gt; nothing bad can ever happen. &lt;em&gt;Can the system crash?&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Progress:&lt;/strong&gt; something good eventually happens. &lt;em&gt;Will the system be reactive to requests?&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Security:&lt;/strong&gt; no secret is ever leaked. &lt;em&gt;Does the system protect sensitive information from intruders?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Analysing these properties is vastly more complicated for concurrent software: the decentralised interaction between processes introduces much more subtle behaviour than what is found in sequential centralised computation. This superior complexity is reflected by the level of formal methods adoption by the industry. Success stories such as Facebook’s Infer and Microsoft SLAM typically focus on safety of essentially sequential programs. Concurrency-related aspects are either grossly over-approximated, ignored, or handled by informal arguments. The main reason for this disconnect is what I call the &lt;strong&gt;analysis scalability problem&lt;/strong&gt;. A proof certifying safety of a concurrent system needs to take into consideration all possible executions, sometimes in an open environment. The space of all possible interactions and interferences is so large and complex that we lack proper tools to reason about it, both manually and automatically. In other words, our understanding of concurrency does not scale, yet.&lt;/p&gt;

&lt;h2 id=&quot;my-approach&quot;&gt;My approach&lt;/h2&gt;

&lt;p&gt;Concurrent software is difficult: difficult to design, to understand, and to formally analyse.
Software engineers have developed a number of patterns, strategies, practices to help &lt;em&gt;designing&lt;/em&gt; concurrent software.
Two invaluable principles used to tame the complexity of design are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Locality &amp;amp; Composition&lt;/strong&gt;&lt;br /&gt;
 Software should be the composition of loosely-coupled components interacting in a local way.
 More concretely, a component should affect and be affected by a well-identified set of resources and processes; thus avoiding global effects, which give rise to unmanageable monolithic systems. 
 The behaviour of a composite system should be a simple composition of the behaviour of the individual components.&lt;br /&gt;
 I call this a &lt;em&gt;compositional&lt;/em&gt; design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abstraction&lt;/strong&gt;&lt;br /&gt;
 Software is built on top of other software. The functionality of a component should be packaged into an external interface which hides the specific internal implementation choices.
 The software component thus becomes reusable.&lt;br /&gt;
 I call this a &lt;em&gt;modular&lt;/em&gt; design.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The VeSPA approach is to promote these principles from guides to the design, to strategies for proving correctness, of systems.
Specifically, a proof for a software component should be as compositional as the design of the system. It should also be as reusable as the software component.
By making proofs compositional and modular, we can solve the analysis scalability problem: proving a system correct has the same complexity as designing it.
Proving the interaction of loosely-coupled components correct would be done by composing loosely-coupled proofs.
Reusing a software component would allow its correctness proof to be reused.
Thanks to abstraction, re-implementations of a software component which satisfy the same external interface would only require to re-prove correctness of the component, but not of the component that use its external interface.&lt;/p&gt;

&lt;p&gt;To realise this vision, VeSPA attacks the analysis scalability problem for Progress and Security of concurrent software, from the point of view of Verified Specification. A specification is a formalisation of the intended behaviour of a software component. A specification is verified against a component, when there is formal proof that the component indeed has the behaviour described by the specification.
The design of specifications is crucial in supporting Locality&amp;amp;Composition and Abstraction.
Current specification formats for concurrent systems fundamentally lack these characteristics, especially if one considers Progress and Security.
VeSPA’s line of attack is based on a synergy between insights gained in my previous work and Gardner’s.&lt;/p&gt;

&lt;p&gt;For more on the project &lt;a href=&quot;/research/projects/VeSPA&quot;&gt;&lt;strong&gt;watch this space&lt;/strong&gt;&lt;/a&gt;!&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0100</pubDate>
        <link>http://emanueledosualdo.com/blog/2018/announce-marie-curie-fellowship.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/blog/2018/announce-marie-curie-fellowship.html</guid>
        
        <category>projects</category>
        
        <category>VeSPA</category>
        
        
      </item>
    
      <item>
        <title>Magritte, and the scientist's condition</title>
        <description>&lt;p&gt;I always liked Magritte, his witty enigmas on frame, the hard fundamental questions he explores with such clarity.
I particularly resonate with the questions about language and meaning: these fundamental questions motivate both my interests in Computer Science and in Music.&lt;/p&gt;

&lt;p&gt;About a year ago, I went with some friends to the Schirn museum in Frankfurt which hosted a temporary exposition entitled &lt;em&gt;“Magritte. The Treachery Of Images”&lt;/em&gt;.
Among many notable works, two of them suggested to me a metaphor that I want to share with you:
&lt;em&gt;La condition humaine&lt;/em&gt; (the human condition) and 
&lt;em&gt;La belle captive&lt;/em&gt; (the beautiful prisoner).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;La condition humaine&lt;/em&gt; plays with perception, representation, the concept of reality.&lt;/p&gt;

&lt;figure&gt; &lt;img src=&quot;/images/posts/2018-02-20-the-scientists-condition/magritte-the-human-condition.jpg&quot; /&gt; &lt;figcaption&gt;&lt;p&gt;&lt;strong&gt;René Magritte&lt;/strong&gt;, &lt;em&gt;La condition humaine&lt;/em&gt; (1935)&lt;/p&gt;
&lt;/figcaption&gt; &lt;/figure&gt;

&lt;p&gt;The theme of the painting frame containing an image indistinguishable from the background is reinterpreted with a strong reference to Plato’s &lt;em&gt;allegory of the cave&lt;/em&gt;.
The viewer is in the cavern, as all humanity, forced to look outside facing the dilemma of believing one’s own perception.
Is the background real? Is the frame real? How can I know the difference between what’s on the frame and what’s behind it? What if the whole picture is a painting, including the cavern?
The enigma is so poignantly expressed, the question underlined by the title so powerful.&lt;/p&gt;

&lt;p&gt;Not far from it, another painting resonated with the first: &lt;em&gt;La belle captive&lt;/em&gt;.
This time the setting is a beach, another frame mocking the background in front of us.&lt;/p&gt;

&lt;figure&gt; &lt;img src=&quot;/images/posts/2018-02-20-the-scientists-condition/magritte-la-belle-captive.jpg&quot; /&gt; &lt;figcaption&gt;&lt;p&gt;&lt;strong&gt;René Magritte&lt;/strong&gt;, &lt;em&gt;La belle captive&lt;/em&gt; (1950)&lt;/p&gt;
&lt;/figcaption&gt; &lt;/figure&gt;

&lt;p&gt;There is a crucial detail in this painting that, I think, really sets it apart from the first: the reflection of the fire on the frame.
It is this detail that made me think: the perfect title for this would be &lt;strong&gt;“The scientist’s condition”&lt;/strong&gt;.
I like to read this painting as a metaphor for the scientist’s philosophical stance on reality.
Yes, we are all tricked by our perceptions, and we are trapped in the enigma of what’s real; and Science cannot resolve this enigma for us.
But Science has the crucial role of the fire in &lt;em&gt;La belle captive:&lt;/em&gt; it constantly reminds us of the issue, and prevents us from indulging in a comforting self-delusion of knowing what is true.
The reflection of the fire on the frame is there to warn us about the possible deception, and serves as a test for what is &lt;em&gt;not&lt;/em&gt; true.&lt;/p&gt;

&lt;p&gt;It always surprises me how the stereotype of the scientist is often portrayed in the media as almost the opposite of what I just proposed: that is, an arrogant hyper-rational know-it-all.
I think this stems from a crucial misunderstanding: being certain (through evidence) of something being &lt;strong&gt;false&lt;/strong&gt;, does not imply the arrogance of knowing what is &lt;strong&gt;true&lt;/strong&gt;.
To the contrary, a scientist cannot ignore what the fire’s reflection is revealing: all your knowledge is, given the facts, simply your best hypothesis of what reality is.&lt;/p&gt;

&lt;p&gt;The scientist’s condition is a difficult one, requiring the strength to constantly deal with ontological uncertainty and ambiguity. But if you want to be intellectually honest, it is the only tenable position.&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://emanueledosualdo.com/blog/2018/the-scientists-condition.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/blog/2018/the-scientists-condition.html</guid>
        
        <category>science</category>
        
        
      </item>
    
      <item>
        <title>Stargazer: understanding the &amp;pi;-calculus, visually</title>
        <description>&lt;p&gt;During my PhD I worked on analysis of concurrent programs,
using the π-calculus as a model of concurrent computation.
The π-calculus is like the λ-calculus of concurrency:
a minimalistic calculus to represent concurrent computation (as opposed to sequential) that is universal (can compute any computable function).
Although there is great beauty in its theory,
people often find its syntax cryptic and is semantics too abstract.
Another common complaint is that it seems too removed from actual programming languages, and is only a toy for theorists.&lt;/p&gt;

&lt;p&gt;To the contrary, I believe the π-calculus has a lot to offer to the wider CS community, if only it was made more accessible.
So, to be able to convey the core concepts and ideas to fellow researchers and students, I developed a simple visual simulator for the π-calculus, which I call &lt;em&gt;Stargazer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; the current version grew out of an initial prototype that I enhanced at each presentation. It is now a bit of a Frankenstein monster inside, and could be made much more efficient. I planned a rewrite before releasing it, but it is clear now that this will never happen.
So I decided to fight my perfectionist’s paralysis and just publish what I have got.&lt;/p&gt;

&lt;h2 id=&quot;try-it-at-stargazeremanueledosualdocom&quot;&gt;Try it at &lt;a href=&quot;http://stargazer.emanueledosualdo.com&quot;&gt;stargazer.emanueledosualdo.com&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;You can try the simulator online, it runs entirely inside the browser.
For best performance, use it with Chrome (although Firefox is also supported).&lt;/p&gt;

&lt;p class=&quot;centered&quot;&gt;&lt;a href=&quot;http://stargazer.emanueledosualdo.com&quot; class=&quot;button primary&quot;&gt;&lt;i class=&quot;fa fa-rocket&quot;&gt;&lt;/i&gt; Try Stargazer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will publish posts on the π-calculus with examples and explanations exploiting the simulator.
For now let me briefly explain the basic concepts.&lt;/p&gt;

&lt;div class=&quot;stargazer with-controls labels&quot; data-gist=&quot;6e54093b297c0f9df01d0c82f65b89f6&quot; data-name=&quot;Server&quot;&gt;&lt;/div&gt;

&lt;p&gt;In the graph above (which is an embedded instance of the simulator)
you see the initial configuration of an example π-calculus program.
In the π-calculus there is a notion of “thread” (called &lt;em&gt;sequential processes&lt;/em&gt;)
and synchronisation is done by message passing over &lt;em&gt;channels&lt;/em&gt;.
In the graph, each active thread is represented by a rectangle and each channel by a dot. Threads are connected to every channel they currently know.
The colours of the threads reflect their current local state.
This graph is commonly called the &lt;em&gt;communication topology&lt;/em&gt; of the system.
If you press “play”, the simulator picks at random enabled transitions and fires them.
The transitions are specified by the program, which in the above example is the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new s. (S[s] | E[s])

S[s] := s(x).νd.( A[x,d] | S[s] )
E[s] := τ.new m.(C[s, m] | E[s]) + τ.νs'.(S[s'] | E[s'] | E[s])
C[s, m] := τ.( Q[s,m] | C1[s,m])
C1[s, m] := m(x).C[s, m]
A[x,d] := x&amp;lt;d&amp;gt;
Q[s,m] := s&amp;lt;m&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you press “open” you will be able to play with the example in the full simulator. Open the “program” sidebar in &lt;em&gt;Stargazer&lt;/em&gt; by pressing the &lt;i class=&quot;fa fa-file-text&quot;&gt;&lt;/i&gt; button to see the program’s code which can be freely edited.&lt;/p&gt;

&lt;h2 id=&quot;help-issues-and-feedback&quot;&gt;Help, issues and feedback&lt;/h2&gt;

&lt;p&gt;For help on how to use it click on the &lt;i class=&quot;fa fa-question&quot;&gt;&lt;/i&gt; button in &lt;em&gt;Stargazer&lt;/em&gt;, where you will find a brief summary of the syntax.
The project is hosted on &lt;a href=&quot;https://github.com/bordaigorl/stargazer&quot;&gt;GitHub&lt;/a&gt;.
I am planning to put some basic information in the &lt;a href=&quot;https://github.com/bordaigorl/stargazer/wiki&quot;&gt;wiki&lt;/a&gt;.
If you find bugs, have feature requests, ideas or comments
you are most welcome to leave a message in the &lt;a href=&quot;https://github.com/bordaigorl/stargazer/issues&quot;&gt;issues&lt;/a&gt; page.&lt;/p&gt;

</description>
        <pubDate>Tue, 31 Oct 2017 00:00:00 +0000</pubDate>
        <link>http://emanueledosualdo.com/blog/2017/stargazer-release.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/blog/2017/stargazer-release.html</guid>
        
        <category>picalculus</category>
        
        <category>fun</category>
        
        
      </item>
    
      <item>
        <title>Why Computer Science is a Science</title>
        <description>&lt;p&gt;The Winter semester just ended here in Kaiserslautern and I gave the last lecture of the &lt;a href=&quot;http://concurrency.cs.uni-kl.de/teaching/ConcurrencyTheory_WS_2016_2017.html&quot;&gt;Concurrency Theory course&lt;/a&gt; I taught.
We covered Petri nets, WSTS and Process Algebra, exploring their theory with the underlying goal of automatic verification.&lt;/p&gt;

&lt;p&gt;In the middle of the course, I realised that there were times where the students were slightly disoriented by the change of register when changing topic. To help them follow better, I came up with a simple notion that helped guiding them to pay attention to the right details.
What I believe was causing the disorientation was what I called a switch from &lt;strong&gt;problem solving mode&lt;/strong&gt; to &lt;strong&gt;conceptual mode&lt;/strong&gt;.
I think making this difference explicit and declaring when I was making the switch helped my student follow the line of reasoning more tightly.
But I believe these two modes of thinking also help understand why Computer Science is rightfully considered to be part of the Natural Sciences.&lt;/p&gt;

&lt;h1 id=&quot;problem-solving-mode-the-art-of-the-lemma&quot;&gt;Problem Solving mode: the Art of the Lemma&lt;/h1&gt;

&lt;p&gt;A lot of results in Theoretical Computer Science rely on hard combinatorial insights. As a consequence, the depth of a result in TCS is often related to the difficulty of this combinatorial core of the argument. Some researchers refer to this core as the “meat” of a result.&lt;/p&gt;

&lt;p&gt;When trying to come up with this kind of results,
or trying to understand them,
the mindset one adopts is what I call the &lt;strong&gt;problem solving mode&lt;/strong&gt;,
that is, your attention is directed to details of the mechanics of a formally well-defined problem, a “puzzle”.
An instance of a puzzle could be
    “How long can the minimal covering paths in a Petri net be?”.&lt;sup id=&quot;fnref:rackoff&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rackoff&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;This mode of thinking is the main one used in engineering work:
you are presented with a complicated but circumscribed problem and apply some mathematical insight to provide a solution.
In CS, the puzzles we face range from the very practical
(“How do you sort an array as quickly as possible?”) 
to the very abstract
(“How do you reduce the halting problem to a problem in arithmetic?”).
But at the core, they require a similar mindset to find a solution.
I would call problem-solving the “Art of the Lemma”.&lt;/p&gt;

&lt;p&gt;Worthwhile puzzles are however never formulated in a vacuum:
they arise as milestones in a wider conceptual framework that motivates their relevance and allows them to be defined in the first place.
The activity of coming up with such a framework requires the use of what I call &lt;strong&gt;conceptual mode&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&quot;conceptual-mode-the-art-of-the-definition&quot;&gt;Conceptual mode: the Art of the Definition&lt;/h1&gt;

&lt;p&gt;Problem solving mode is what makes many put CS and Engineering together in the same category.
I would argue that CS as a whole, sets itself aside from pure Engineering because of its substantial use of what I call &lt;strong&gt;conceptual mode&lt;/strong&gt;.
This mode of thinking is characterised by the exploratory experimentation with some basic phenomenon that we are trying to understand. The conceptualisation process works by formulating rigorous models of the phenomenon at hand and putting these models to test.
It heavily involves abstraction, formalisation and generalisation abilities. 
The outcome of the process is a set of basic assumptions and definitions that would form the basis for a &lt;em&gt;language&lt;/em&gt; to express facts and properties regarding the phenomenon under study.
I would call conceptualisation the “Art of the Definition”.&lt;/p&gt;

&lt;p&gt;Problems that are solved by employing the conceptual mindset are typically not well-defined and ambiguous. Examples could be “What is behaviour?”&lt;sup id=&quot;fnref:beh&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:beh&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; or “What does it mean for an analysis to be sound?”.&lt;sup id=&quot;fnref:absint&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:absint&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Big tech companies like Google or Facebook have interview processes set up to test the purely problem-solving abilities of candidates. Their reputation then does the rest: the problem solving aspect of CS is often over-emphasised and CS may be reduced to puzzle-solving from the perspective of an outsider.
This makes sense if you consider that these companies are looking, most of the times, for Software Engineers. But in a University we aim at forming professionals that are prepared both technically &lt;em&gt;and&lt;/em&gt; culturally. Only a balance between the conceptual and problem solving aspects of our discipline can achieve this.&lt;/p&gt;

&lt;h1 id=&quot;zen-in-the-art-of-research&quot;&gt;Zen in the Art of Research&lt;/h1&gt;

&lt;p&gt;The two modes are both absolutely essential in solving typical CS problems.
They are not competing but simply complementary.
I find that making the switch between the two modes a conscious process,
helps focusing on the important aspects of the problem and coming to a solution in a more enlightened way.&lt;/p&gt;

&lt;p&gt;Conceptualisation provides direction and a strong relation with the phenomenon under study, producing puzzles that are not meaningless tricks.
Problem solving gives depth to conceptualisation, allowing non-obvious consequences to be drawn from the premises.&lt;/p&gt;

&lt;p&gt;If I think of the state of mind when doing conceptual work, I am reminded of the very nice description of the process of shooting an arrow in the book “Zen in the art of archery”, by the philosopher Eugen Herrigel. Although the book has many limitations, I still appreciate the attempt of the author to communicate to a Western audience ideas grounded in assumptions so distant from ours. Anyway, the description of the state of mind when shooting an arrow resonates, I think, with what one frequently experiences when doing research. The almost obsessive search for the right shot done in the training, striving for a liberation from preconceived assumptions, or emotional attachments to a dead-end. Then the moment of enlightenment: The Definition flows finally in a shape that feels right. And lemmas start to fall into place.
The arrow leaves the bow and hits the target.
Once The Definition has been produced, it may result completely obvious to the authors and even obvious to the readers. But this should not fool them: the path leading to its formulation was not obvious at all and to really appreciate its depth the reader must often go through the same path him/herself.&lt;/p&gt;

&lt;h1 id=&quot;computer-science-is-a-science&quot;&gt;Computer Science is a Science&lt;/h1&gt;

&lt;p&gt;One may argue that Theoretical Computer Science is actually a branch of Mathematics and as such is not related to the Natural world in the same way as Biology or Physics are. I disagree with this position: the subject matter of CS is &lt;em&gt;information&lt;/em&gt; and &lt;em&gt;computation&lt;/em&gt;. Both are essential aspects of natural phenomena: every time we witness a computation in the physical world we are putting the theories of CS to the test.
In fact this can be traced back to the beginning of CS as a discipline, which was marked by two complementary discoveries: the conceptual framework of computable functions and the technical possibility of testing this framework with computers.&lt;/p&gt;

&lt;p&gt;Pure problem solving is essentially Engineering.
Pure conceptual mode is Philosophy.
Computer Science hits that sweet spot in between the two: it is the combination of the two modes that gives the discipline the relevance and depth of a Science.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:rackoff&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The answer is doubly-exponential in the size of the input, as proved in Rackoff’s lower-bound for Petri net coverability. &lt;a href=&quot;#fnref:rackoff&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:beh&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In the course we answer this question by introducing Bisimulations. The general question of “What is the meaning of a program” led to the development of the field of Semantics. &lt;a href=&quot;#fnref:beh&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:absint&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;A compelling answer can be found in the Abstract Interpretation framework. &lt;a href=&quot;#fnref:absint&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://emanueledosualdo.com/blog/2017/why-computer-science-is-a-science.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/blog/2017/why-computer-science-is-a-science.html</guid>
        
        <category>science</category>
        
        
      </item>
    
      <item>
        <title>The art of the misspelling</title>
        <description>&lt;p&gt;My name is Emanuele D’Osualdo.
I know what you are thinking, and I do not blame you.
Actually, let me get this straight from the start:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I hereby forgive you, fully and pre-emptively,
for misspelling or mispronouncing my name or surname.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yes, my name is long and complicated (although it has been pointed out to me that Polish names can be orders of magnitude more complicated),
but in fact I am always amused from the strange misspellings I collected during the years.&lt;/p&gt;

&lt;p&gt;Before going into that, if you are wondering about the pronunciation,
here is my name pronounced correctly:&lt;/p&gt;

&lt;audio src=&quot;/doc/name.mp3&quot; controls=&quot;controls&quot;&gt;
  &lt;a href=&quot;/doc/name.mp3&quot; class=&quot;button&quot;&gt;
      Click here to play
      &lt;i class=&quot;fa fa-play&quot;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/audio&gt;

&lt;h1 id=&quot;misspellings-of-dosualdo&quot;&gt;Misspellings of D’Osualdo&lt;/h1&gt;

&lt;p&gt;My surname is weird even to Italian ears. Common misspellings include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;D’Osvaldo&lt;/strong&gt; (Osvaldo is an old-fashioned Italian name)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D’Osvualdo&lt;/strong&gt; (if you are not sure, put both)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D’Osvivaldo&lt;/strong&gt; (strangely reminiscent of Vivaldi)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gesualdo&lt;/strong&gt; (another Italian composer!)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D’Osulado&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;d’odusldo&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dosualvo&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dosvalbo&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D’osnaldro&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dosvlaudo&lt;/strong&gt; — or something like this where it is clear that the one who typed it simply gave up after three letters&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;d’Osualdo&lt;/strong&gt; or just &lt;strong&gt;Osualdo&lt;/strong&gt; — I get this a lot in Germany, where they seem to interpret the “D’” as an optional decoration. Main drawback: I may be listed under “O” in alphabetic order!&lt;/li&gt;
  &lt;li&gt;New entry: &lt;strong&gt;Dr. Oswaldo&lt;/strong&gt; — that’s how Germans tend to pronounce it.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D’Oscualdo&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;the-apostrophe&quot;&gt;The apostrophe&lt;/h1&gt;

&lt;p&gt;A separate category of misspellings concerns the apostrophe:
we are in 2016 and still computer systems systematically stumble when dealing with my surname.
The apostrophe is to an online form
what a mouse is to an elephant.&lt;/p&gt;

&lt;p class=&quot;centered&quot;&gt;&lt;img src=&quot;/images/posts/2016-11-02-the-art-of-the-misspelling/cyberman.gif&quot; /&gt; 
  &lt;img src=&quot;/images/posts/2016-11-02-the-art-of-the-misspelling/apostrophe.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sometimes it is simply rejected, sometimes the apostrophe gets removed with arbitrary fixes such as replacing it with a space or removing the character altogether.
And these are the good cases. In others it simply makes the system fail because of improper handling of user-provided data.
Yes I am &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;Little Bobby Tables&lt;/a&gt;!&lt;/p&gt;

&lt;p class=&quot;wide-image&quot;&gt;&lt;a href=&quot;http://xkcd.com/327/&quot;&gt;&lt;img src=&quot;http://imgs.xkcd.com/comics/exploits_of_a_mom.png&quot; alt=&quot;Exploits of a mom (xkcd.com)&quot; title=&quot;Exploits of a mom (xkcd.com)&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://xkcd.com/327/&quot; class=&quot;credits&quot;&gt;xkcd.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In fact it is the apostrophe in my surname that made me independently come up with my first SQL-injection exploit. Good times.&lt;/p&gt;

&lt;p&gt;In Germany the problem is aggravated by the fact that the German language uses the apostrophe very rarely, so people just use the acute accent symbol ` instead, which is more easily found on keyboards!&lt;/p&gt;

&lt;p&gt;And then there’s my first name.&lt;/p&gt;

&lt;h1 id=&quot;the-curse-of-emmanuelle&quot;&gt;The curse of Emmanuelle&lt;/h1&gt;

&lt;p&gt;To make things worse, my first name, &lt;em&gt;Emanuele&lt;/em&gt;, lends itself to all sorts of ambiguities and misspellings.
The list of similar, but distinct, names is long:
Emmanuele, Emmanuelle, Emanuelle, Manuel, Manuele, Manuelle…
To those you have to add the misspellings (once I got Emanuale).
Pronunciation is a further issue: at best I get something that resembles &lt;em&gt;manual&lt;/em&gt;, at worst I get some irrecognisable mash of &lt;em&gt;m&lt;/em&gt;s, &lt;em&gt;n&lt;/em&gt;s and &lt;em&gt;l&lt;/em&gt;s.&lt;/p&gt;

&lt;p&gt;The funniest story around my first name comes from my Erasmus in Turkey.
I arrive in Istanbul and go to my hostel.
They ask for my ID, start transcribing the data…when they stop at the name and start giggling.
Ok, fine, it’s a strange name, whatever, just give me the keys of the room.
After some rest, I go back to the reception and the guy starts giggling again after seeing me. Uh, ok, weird. I explore the surroundings, go back to the hostel. Now the receptionist is with a friend and as soon as I show up he says my name in a very refined attempt to signal to his friend that “This is the guy I told you about”. Ok, guy from the reception, I confront you: what’s so funny?!?
«Well…you know…when I was little…there was this, uhm, “movie”, you know the ones that they play late at night…it was called &lt;em&gt;Emmanuelle&lt;/em&gt;. Every Turk knows it!»
This is true, apparently “Emmanuelle” was a popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Emmanuelle_(film)&quot;&gt;erotic movie from the seventies&lt;/a&gt;.
Except:&lt;/p&gt;

&lt;p class=&quot;centered&quot;&gt;THE MALE ITALIAN NAME EMANUELE&lt;br /&gt;
IS &lt;strong&gt;NOT&lt;/strong&gt;&lt;br /&gt;
THE FEMALE FRENCH NAME EMMANUELLE&lt;/p&gt;

&lt;p&gt;Beside the spelling and the different language,
the pronunciation is completely different.
Of course to Turkish ears the two are indistinguishable.
With obvious repercussions on my introductions:&lt;/p&gt;

&lt;p&gt;- «Hello I am Murat»&lt;br /&gt;
- «Nice to meet you, I am…MANU»&lt;br /&gt;
[Friend who knew me from before]&lt;br /&gt;
- «“Manu”? No…tell him your full name!»&lt;br /&gt;
[&lt;em&gt;nudge nudge, wink wink&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Yes, every time I introduced myself to a &lt;em&gt;male&lt;/em&gt; Turkish guy I got the giggles back!&lt;/p&gt;

&lt;!-- ## The worst list of nicknames on earth

Although people used many nicknames for me in the past---Ema, Emanu, Lele, Dosu---the one that I commonly use is Manu.
Feel free to use it! --&gt;

</description>
        <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
        <link>http://emanueledosualdo.com/blog/2016/the-art-of-the-misspelling.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/blog/2016/the-art-of-the-misspelling.html</guid>
        
        <category>fun</category>
        
        
      </item>
    
      <item>
        <title>What is that weird animation on my homepage?</title>
        <description>&lt;p&gt;So nice of you to ask! What you are looking at is an example of the systems we study in Concurrency Theory. In short, it is an example of a mathematical formalisation of a simple internet protocol; the aim of our research is to design algorithms that can prove properties of these kinds of models.&lt;/p&gt;

&lt;p&gt;The simulation on the homepage is running a fixed program modelling a server/client system. The orange boxes are the clients, the blue ones are servers;
the green boxes are messages to the server (dark) or to the clients (light).&lt;/p&gt;

&lt;div class=&quot;large stargazer with-controls&quot; data-zoom=&quot;.5&quot; data-gravity=&quot;true&quot; data-play-on-load=&quot;true&quot;&gt;
    &lt;script type=&quot;text/x-stargazer&quot;&gt;new s. (S[s] | new m.C[s,m] | new m.C[s,m] | new m.C[s,m])
| new s. (S[s] | new m.C[s,m] | new m.C[s,m])
| new s. (S[s] | new m.C[s,m] )
| new s. (S[s] | new m.C[s,m] | new m.C[s,m] | new m.C[s,m])

S[s] := s(x).νd.( A[x,d] | S[s] )
C[s, m] := τ.( Q[s,m] | C1[s,m])
C1[s, m] := m(x).C[s, m]
Q[s,m] := s&lt;m&gt;
A[x,d] := x&lt;d&gt;
    &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;More precisely, the displayed animation is a visual simulation of the evolution of a &lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%A0-calculus&quot;&gt;π‑calculus&lt;/a&gt; program. The boxes are sequential processes, i.e. threads, and the dots are names, i.e. channels.&lt;/p&gt;

&lt;p&gt;You can try the simulator and experiment with the π‑calculus by clicking here:&lt;/p&gt;

&lt;p class=&quot;centered&quot;&gt;&lt;a href=&quot;http://stargazer.emanueledosualdo.com&quot; class=&quot;button primary&quot;&gt;&lt;i class=&quot;fa fa-rocket&quot;&gt;&lt;/i&gt;Stargazer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I wrote the simulator in JavaScript and &lt;a href=&quot;https://d3js.org/&quot;&gt;D3.js&lt;/a&gt; to support my presentation on the contents of &lt;a href=&quot;/research/#thesis&quot;&gt;my Ph.D. thesis&lt;/a&gt;. The code evolved from a simple prototype and I am in the process of rewriting it completely.
I hope you will enjoy it even if it is unfinished!&lt;/p&gt;

&lt;blockquote class=&quot;note&quot;&gt;
  &lt;p&gt;&lt;a href=&quot;/feed.xml&quot; class=&quot;button primary&quot;&gt;Subscribe&lt;/a&gt;
If you’d like to know more, watch this space for an upcoming write-up about the π‑calculus&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 09 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://emanueledosualdo.com/explain-picalc.html</link>
        <guid isPermaLink="true">http://emanueledosualdo.com/explain-picalc.html</guid>
        
        <category>picalculus</category>
        
        
      </item>
    
  </channel>
</rss>
